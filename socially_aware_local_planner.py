# -*- coding: utf-8 -*-
"""socially aware local planner.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1n2g2q_iRgpPYmaJUO6eqtF_3ypRcFpfF
"""

import numpy as np 
import matplotlib.pyplot as plt
from matplotlib.patches import Rectangle 
import math

class Object:
  def __init__(self, x0, y0):
    self.x, self.y = x0, y0

f_goal = -0.1    # force constant for goal (-ve for attractive field)  
eps = 1e-5        # constant added to prevent singularity  
f_obj = 1.7         # force constant for objects

def potential(x0, y0, x1, y1):
  # Goal potential 
  d = (grid - x1)**2 + (grid - y1)**2
  V = f_goal*(d**0.5)
  # object potential 
  m = (y1 - y0)/((x1 - x0) + 1e-5)
  c = y1 - x1*m 
  den = (1 + m**2)**0.5
  for obj in objects: 
    d = abs(obj.y - (m*obj.x + c))/den
    V += f_obj*((d + eps)**-1)
  return V

ang = 1.0     # coefficients for optimisation 
trans = 0.1
ref = 0.09

def effort(x0, y0, x1, y1, th0):
  # rotational effort
  theta = math.atan(abs(y1 - y0)/abs(x1 - x0))
  del_th = theta - th0
  #translational effort
  d = (x1 - x0)**2 + (y1 - y0)**2 
  # total control effort
  eff = ang*(del_th**2) + trans*d
  return eff

# follow the proposed trajectory closely
def reference_error(x_ref, y_ref, x0, y0):
  err = (x_ref - x0)**2 + (y_ref - y0)**2
  return ref*err

max_iter = 20     # maximum allowed iterations
alph_opt = 0.05    # step size 
thresh = 7.0
pot_thresh = 0.05 
exp_opt = 0.05

def step_opt(x_ref, y_ref, x0, y0, theta):
  # (x0, y0) is the current position
  # theta is the current orientation
  # (x_ref, y_ref) is the proposed next position
  # this function outputs the next position that
  #     avoid collisions with objects,
  #     minimises control effort
  x1, y1 = x_ref, y_ref
  err = 0
  for i in range(0, max_iter+1):
    pot = potential(x0, y0, x1, y1)
    err = effort(x0, y0, x1, y1, theta) + reference_error(x_ref, y_ref, x1, y1) + pot
    if (abs(err) < thresh and pot < pot_thresh) or i == max_iter:
      break
    u_x, u_y = np.random.rand()-0.5, np.random.rand()-0.5
    u_mag = (u_x**2 + u_y**2)**0.5
    u_x, u_y = u_x/u_mag, u_y/u_mag
    x_down, y_down = x1 - exp_opt*u_x, y1 - exp_opt*u_y
    x_up, y_up = x1 + exp_opt*u_x, y1 + exp_opt*u_y
    # gradient 
    err_down = effort(x0, y0, x_down, y_down, theta) + reference_error(x_ref, y_ref, x_down, y_down) + potential(x0, y0, x_down, y_down) 
    err_up = effort(x0, y0, x_up, y_up, theta) + reference_error(x_ref, y_ref, x_up, y_up) + potential(x0, y0, x_up, y_up)
    grad_x = (err_up - err_down)*u_x/exp_opt
    grad_y = (err_up - err_down)*u_y/exp_opt
    grad_x = max(min(grad_x, 2.5), -2.5)
    grad_y = max(min(grad_y, 2.5), -2.5)
    #update 
    x1 = max(0, x1 - alph_opt*grad_x)
    y1 = max(0, y1 - alph_opt*grad_y)
    # print(x1, y1)
  
  # print("end")
  return x1, y1, err

def feedback(x0, y0):
  err = 0
  # query all humans for feedback 
  # can instead just ask those in proximity 
  for i in range(0, humans.shape[0]):
    d = (humans[i, 0] - x0)**2 + (humans[i, 1] - y0)**2
    d = d**0.5
    # focus on proximity discomfort only (test purpose) 
    if (d <= c_rad[i]):
      err += 1            # collect feedback
  return err

mv_rad = 0.6
def move(humans):
  mv_len = np.random.rand(p,1)*mv_rad
  mv_vect = np.random.rand(p, 2) - 0.5
  mv_vect = mv_len*(mv_vect/np.expand_dims((mv_vect**2).sum(axis=1)**0.5 + 1e-4, axis = 1))
  humans = humans + mv_vect
  humans[humans[:, 0]<0] = 2
  humans[humans[:, 1]<0] = 2
  humans[humans[:, 0]>18] = 18
  humans[humans[:, 1]>18] = 18
  return humans

def visualise(x, y, th, ax, fig):
  # plot = plt.figure()
  # ax = plot.gca()
  ax.clear()
  for i in range(0, p):
    cir = plt.Circle((humans[i][0], humans[i][1]), c_rad[i], color='r',fill=False)
    ax.add_patch(cir)
  plt.scatter(humans[:, 0], humans[:, 1], s=7)
  plt.arrow(x-math.cos(th)*0.25, y-math.sin(th)*0.25, math.cos(th)*0.5, math.sin(th)*0.5)
  obj1_r = Rectangle((obj1.x - obj_width/2, obj1.y - obj_width/2), obj_width, obj_width, color='r')
  obj2_r = Rectangle((obj2.x - obj_width/2, obj2.y - obj_width/2), obj_width, obj_width, color='r')
  ax.add_patch(obj1_r)
  ax.add_patch(obj2_r)
  plt.grid(linestyle='dotted')
  fig.canvas.draw_idle()
  plt.pause(0.3)

grid = 20
p = 30
humans = np.random.rand(p, 2)*16 + 2
c_rad = np.random.rand(p)*0.1 + 0.3

obj_width = 2
obj1 = Object(8, 5)
obj2 = Object(11, 13)
objects = [obj1, obj2]
step = 1.0

# Trajectory generator 
x, y = 0, 0
th = math.atan(1)
N = 10
traj = []
gamma = 0.05     #exploration parameter
alph = 0.1      #update step size
plt.ion()
fig, ax = plt.subplots()
ax.set_xticks(np.arange(-1, grid+1, 5))
ax.set_yticks(np.arange(-1, grid+1, 5))
while x < 20 and y < 20:
  traj = traj + [[x, y]]
  humans = move(humans)
  x_, y_ = grid - x, grid - y
  mag_ = x_**2 + y_**2
  x_, y_ = x_/(mag_**0.5), y_/(mag_**0.5)
  x_ref, y_ref = x + step*x_, y + step*y_     # initialise the next suited position
  x1, y1 = x_ref, y_ref
  for i in range(0, N+1):
    m_x1, m_y1, err = step_opt(x1, y1, x, y, th)
    f_err = feedback(m_x1, m_y1)
    if f_err == 0 or i == N:
      th = math.atan(abs(m_y1 - y)/abs(m_x1 - x))
      x = m_x1 
      y = m_y1
      break
    #perturb
    u_x, u_y = np.random.rand()-0.5, np.random.rand()-0.5
    u_mag = (u_x**2 + u_y**2)**0.5
    u_x, u_y = u_x/u_mag, u_y/u_mag
    x_down, y_down = x1 - gamma*u_x, y1 - gamma*u_y
    x_up, y_up = x1 + gamma*u_x, y1 + gamma*u_y
    #gradient estimation
    m_xd, m_yd, m_derr = step_opt(x_down, y_down, x, y, th)
    m_xu, m_yu, m_uerr = step_opt(x_up, y_up, x, y, th)
    err_up = 5*feedback(m_xu, m_yu) + ((x1 - m_xu)**2 + (y1 - m_yu)**2)**0.5 
    err_down = 5*feedback(m_xd, m_yd) + ((x1 - m_xd)**2 + (y1 - m_yd)**2)**0.5 
    grad_x = (err_up - err_down)*u_x/gamma
    grad_y = (err_up - err_down)*u_y/gamma
    grad_x = max(min(grad_x, 2.5), -2.5)
    grad_y = max(min(grad_y, 2.5), -2.5)
    #update
    x1 = max(x1 - alph*grad_x, 0)
    y1 = max(y1 - alph*grad_y, 0)
  visualise(x, y, th, ax, fig)
traj += [[x, y]]

print(np.array(traj))

